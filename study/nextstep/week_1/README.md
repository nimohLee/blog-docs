## 1주차
### 객체지향 생활 체조 원칙
객체지향 생활 체조 원칙은 소트웍스 앤솔러지 책에서 다루고 있는 내용으로 객체지향 프로그래밍을 잘 하기 위한 9가지 원칙을 제시하고 있다.

이 책에서 주장하는 9가지 원칙은 다음과 같다.

- 규칙 1: 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.
- 규칙 2: else 예약어를 쓰지 않는다.
- 규칙 3: 모든 원시값과 문자열을 포장한다.
- 규칙 4: 한 줄에 점을 하나만 찍는다.
- 규칙 5: 줄여쓰지 않는다(축약 금지).
- 규칙 6: 모든 엔티티를 작게 유지한다.
- 규칙 7: 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- 규칙 8: 일급 콜렉션을 쓴다.
- 규칙 9: 게터/세터/프로퍼티를 쓰지 않는다.

이 원칙 중에 내가 제일 안되는 것은 규칙3과 규칙 8, 규칙 9이다. 나머지는 실무에서도 신경쓰면서 개발을 하고 있는데 3,8,9는 아무리 신경써도 실무에 쉽게 적용하기가 어려웠다. 또 실무에서는 상사들이 자바 파일이 많아지는 것을 선호하지 않는다. 이번 과정을 통해서라도 3,8,9를 매우 집중하여 클린한 객체지향 코드를 작성해보고자 한다.

### 문자열 덧셈 계산기
가장 첫 단계에서는 문자열로 들어오는 식을 구분자로 나누어 더하는 계산기를 구현했다.
예를 들어 `"1,2,3"`이 들어오면 `,`를 구분자로 하고 1+2+3의 결과인 6을 반환해야 한다.

이 과정은 매우 간단하기 때문에 나름 잘 구현했다. 첫 단계다 보니 리뷰어님들도 모두 소소한 피드백만 해주시고 머지 해주셨다.

#### 질문에 대한 피드백
- 질문 1

메서드의 책임을 줄이고자 메서드 추출을 많이 했습니다. 이 때 private 메서드가 너무 많이 생기는데, 괜찮은건가요? private 메서드는 테스트를 하기 어려워서 그리 좋은 방법 같지 않다고 생각합니다.

- 피드백

메서드를 작게 나누는 것은 좋다고 생각해요
너무 많은 private 메서드가 생성된다면 클래스의 책임이 크지 않은가 고민해 볼 수 있을 것 같은데요
즉 리팩토링의 신호라고 볼 수도 있을 것 같아요
지금 고민하신 부분은 모든 미션에서 자연스럽게 다루어지니 직접 경험해 보시면 좋을 것 같습니다 😃

- 정리

너무 많은 private 메서드가 생성된다면 리팩터링의 신호라는 점이 인상깊었다. 메서드 분리를 하다보면 항상 private 메서드가 너무 많아져서 고민이었었는데, 이것을 신호로 보고 객체를 분리할 수 있겠다고 생각했다.

### 자동차 경주
처음으로 `getter`를 아예 안 써보려니 머리에 쥐가 났다. 조영호님의 `객체지향의 사실과 오해`같은 책을 보면 "객체에게 무언가를 달라고 요청하지말고, 무언가를 하라고 시켜라" 라고 한다. `getter`를 사용하지 않는 것인데, `getter`로 데이터를 가져와서 비즈니스 로직을 수행하면 그것은 객체지향이 아니라 절차지향이다.
데이터와 프로세스를 서로 다른 곳에 위치하면 자율적인 객체지향이 깨지게 된다.

여기까지 이론적인 내용이다. 

너무 머리아팠다. "**객체가 무슨 책임까지 가지고 있어도 되는가**" 에 대한 경계를 결정하기가 어려웠다.

#### 피드백
1. `Random`과 같은 객체는 매번 생성할 필요 없다.

```java
class RandomUtil {
  private static final BOUND = 9;
  
  public static int randomNumberZeroToNine() {
        return new Random().nextInt(BOUND);
  }
}
```
`randomNumberZeroToNine()`는 요청이 들어올 때마다 `Random` 인스턴스를 새로 생성해서 `nextInt`를 실행한다. 굳이 그럴 필요가 없는 게 `Random` 객체가 불변객체도 아니고 유틸성이기 때문에 하나의 인스턴스만 사용해도 아무 문제가 없을 것이다.

```java
class RandomUtil {
  private static final BOUND = 9;
  private static final Random random = new Random();

  public static int randomNumberZeroToNine() {
        return random.nextInt(BOUND);
  }
}
```

클래스 변수로 올릴 수 있을 것이다. 하지만 이게 끝이 아니다. 지금 변수 `random`은 `static final`로 상수이다. 나는 지금껏 원시값만 상수라고 생각하고 대문자 컨벤션을 적용했는데, 객체도 예외는 아니다.
이를 수정해주자!
```java
class RandomUtil {
  private static final BOUND = 9;
  private static final Random RANDOM = new Random();

  public static int randomNumberZeroToNine() {
        return RANDOM.nextInt(BOUND);
  }
}
```