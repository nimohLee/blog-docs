ë°±ì¤€: https://www.acmicpc.net/problem/14502

## ë¬¸ì œ

![image1](./images/image1.png)
![image2](./images/image2.png)
![image3](./images/image3.png)

## ë¬¸ì œ í’€ì´
ì •ë‹µ ë¹„ìœ¨ì´ ë¬´ë ¤ 54%ê°€ ë„˜ëŠ”ë‹¤. ê·¸ëŸ°ë°ë„ ë‚˜ëŠ” ë‚´ í˜ìœ¼ë¡œ í’€ì§€ ëª»í–ˆë‹¤.

ë¬¸ì œëŠ” í•´ê²°ì„ ìœ„í•œ ì•„ì´ë””ì–´ê°€ ë– ì˜¤ë¥´ì§€ ì•Šì•˜ë‹¤. ë°”ì´ëŸ¬ìŠ¤ê°€ ì—†ëŠ” ëª¨ë“  '0'ì„ 3ê°œ ê³ ë¥´ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ êµ¬í•˜ë ¤ê³  ìƒê°í–ˆì—ˆëŠ”ë° 'ê·¸ë ‡ê²Œ ë¬´ì‹í•  ë¦¬ê°€ ì—†ì§€..'ë¼ëŠ” ìƒê°ì— ë§ë„ ì•ˆë˜ëŠ” í’€ì´ë¼ê³  ìƒê°í•˜ê³  ë‹¤ë¥¸ ë™ë™ ì•“ë‹¤ê°€ ê²°êµ­ êµ¬ê¸€ë§ì„ í–ˆë‹¤...ğŸ¥²

ìš°ì„  `3 <= N,M <= 8` ë¡œ ë§¤ìš° ì—°êµ¬ì†Œì˜ í¬ê¸°ê°€ ë§¤ìš° ì‘ì•˜ë‹¤. ê·¸ ë§ì€ ì¦‰ìŠ¨ ì—„ì²­ë‚œ ë°˜ë³µì„ ì €ì§ˆëŸ¬ë„ ì•ˆì „í•˜ë‹¤ëŠ” ëœ»ìœ¼ë¡œ ëŠê»´ì¡Œë‹¤.

í•µì‹¬ ë¡œì§ì€ ì´ë ‡ë‹¤.
1. dfsë¥¼ í†µí•´ **3ê°œì˜ ë²½ì„ ì„¸ìš¸ ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜**ë¥¼ êµ¬í•œë‹¤.
2. ê°ê°ì˜ ê²½ìš°ì˜ ìˆ˜ê°€ ì„¸íŒ…ë˜ì—ˆì„ ë•Œ BFSë¥¼ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë ¤ë³¸ë‹¤.
3. BFS, ì¦‰ ë°”ì´ëŸ¬ìŠ¤ê°€ ëª¨ë‘ í¼ì§„ ë’¤ì— ì•ˆì „ì˜ì—­ì˜ ê°œìˆ˜ë¥¼ ì°¾ì•„ë³¸ë‹¤.
4. ì•ˆì „ì˜ì—­ì˜ ìµœëŒ“ê°’ì„ ì¶œë ¥í•œë‹¤.

```java
public class Boj_14502 {
    private static int row;
    private static int column;
    private static int[][] map;
    private static int[][] copyMap;
    private static List<int[]> virusLocation = new ArrayList<>();
    private static int[] dr = {0, 1, 0, -1};
    private static int[] dc = {1, 0, -1, 0};
    private static int safeAreaCount = Integer.MIN_VALUE;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        row = Integer.parseInt(st.nextToken());
        column = Integer.parseInt(st.nextToken());
        map = new int[row][column];

        for (int i = 0; i < row; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < column; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
                if (map[i][j] == 2) {
                    virusLocation.add(new int[]{i, j});
                }
            }
        }

        dfs(0);
        System.out.println(safeAreaCount);
    }

    private static void dfs(int wallCount) {
        if (wallCount == 3) {
            safeAreaCount = Math.max(bfs(), safeAreaCount);
        } else {
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < column; j++) {
                    if (map[i][j] == 0) {
                        map[i][j] = 1;
                        dfs(wallCount+1);
                        map[i][j] = 0; // <<< ë²½ì„ 3ê°œ ì„¸ìš°ê³ , ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë¦° ë’¤ ë‹¤ì‹œ í—ˆë¬¼ì–´ì•¼ ë‹¤ìŒ ë²½ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì„¸íŒ…í•´ë³¼ ìˆ˜ ìˆë‹¤.
                    }
                }
            }
        }
    }

    private static int bfs() {
        boolean[][] visited = new boolean[row][column];
        Queue<int[]> queue = new LinkedList<>();
        for (int[] virus : virusLocation) {
            queue.offer(virus);
        }
        copyMap = new int[row][column];

        for (int i=0; i<map.length; i++) {
            copyMap[i] = map[i].clone();
        }

//        copyMap = map.clone(); << ì–•ì€ ë³µì‚¬

        while (!queue.isEmpty()) {
            int[] polled = queue.poll();
            int curRow = polled[0];
            int curCol = polled[1];

            for (int i=0; i<4; i++) {
                int nextRow = curRow + dr[i];
                int nextCol = curCol + dc[i];

                if (nextRow < 0 || nextCol < 0 || nextRow >= row || nextCol >= column) {
                    continue;
                }

                if (!visited[nextRow][nextCol] && copyMap[nextRow][nextCol] == 0) {
                    queue.offer(new int[]{nextRow, nextCol});
                    copyMap[nextRow][nextCol] = 2;
                    visited[nextRow][nextCol] = true;
                }
            }
        }
        return countSafeArea(copyMap);
    }

    private static int countSafeArea(int[][] map) {
        int result = 0;
        for (int i = 0;i < row; i++) {
            for (int j = 0;j < column; j++) {
                if (map[i][j] == 0) {
                    result++;
                }
            }
        }

        return result;
    }
}
```

ì´ ë¬¸ì œì˜ í•µì‹¬ì€ DFS ë¡œì§ê³¼ ì—°êµ¬ì‹¤ì˜ ë³µì‚¬ì— ìˆë‹¤. BFSëŠ” ë‹¤ë¥¸ BFSë“¤ê³¼ ë‹¤ë¥¼ ë°” ì—†ë‹¤.

### 1. DFSì—ì„œ ì¤‘ìš”í•œ ê²ƒì€ ë²½ì„ ì„¸ìš´ ë’¤ì— ë‹¤ì‹œ í—ˆë¬´ëŠ” ê²ƒì´ë‹¤.

```java
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < column; j++) {
            if (map[i][j] == 0) {
                map[i][j] = 1;
                dfs(wallCount+1);
                map[i][j] = 0;
            }
        }
    }
```
ìœ„ ì½”ë“œëŠ” `dfs()` ë‚´ë¶€ ì½”ë“œì´ë‹¤. ì˜ ë³´ë©´ ì—°êµ¬ì†Œ(map)ì— ë²½ì„ ì„¸ì› ë‹¤(1)ê°€ dfs() í˜¸ì¶œì´ ëë‚˜ê³  ë‹¤ì‹œ í—ˆë¬¸ë‹¤(0). ì´ìœ ëŠ” ë²½ì„ ì„¸ìš°ê³  dfs()ë¥¼ í˜¸ì¶œí•˜ê²Œ ë˜ë©´ ê·¸ ë²½ì´ ì„¸ì›Œì§„ ìƒíƒœë¡œ ë‹¤ìŒ ë²½ì„ ì„¸ìš°ëŸ¬ ì¬ê·€í˜¸ì¶œëœë‹¤. ê·¸ë ‡ê²Œ ë²½ì˜ ê°œìˆ˜ê°€ 3ê°œê°€ ë˜ì—ˆì„ ë•Œ, bfs()ë¥¼ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë¦¬ê³  ì„¸ ë²ˆì§¸ ë²½ë¶€í„° ì²« ë²ˆì§¸ ë²½ê¹Œì§€ ì°¨ë¡€ë¡œ `map[i][j] = 0`ì´ í˜¸ì¶œëœë‹¤.

ê·¸ë˜ì•¼ ë‹¤ìŒ ë²½ ì„¸íŒ… ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì œëŒ€ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

### 2. ì–•ì€ ë³µì‚¬ì™€ ê¹Šì€ ë³µì‚¬
ì—°êµ¬ì†Œì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë¦¬ëŠ” ì‹¤í—˜(BFS)ì„ í•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ì„ì‹œ ì—°êµ¬ì†Œë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤. ì™œëƒí•˜ë©´ ê¸°ì¡´ ì—°êµ¬ì†Œ(`map`)ì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ ë‹¤ í¼íŠ¸ë ¤ë²„ë¦¬ë©´ ë‹¤ìŒ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì •ìƒì ìœ¼ë¡œ ìˆ˜í–‰í•´ë³¼ ìˆ˜ê°€ ì—†ë‹¤.

ì„ì‹œ ì—°êµ¬ì†Œë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ì„œëŠ” ë³µì‚¬ì˜ ê¹Šì´ì— ëŒ€í•´ ì•Œ í•„ìš” ìˆë‹¤. ìë°”ì—ëŠ” ì–•ì€ ë³µì‚¬(Shallow Copy)ì™€ ê¹Šì€ ë³µì‚¬(Deep Copy)ê°€ ìˆë‹¤. ì•„ë§ˆ ëŒ€ë¶€ë¶„ì˜ ì–¸ì–´ì— ìˆëŠ” ê°œë…ì¼ ê²ƒì´ë‹¤.

#### ì–•ì€ ë³µì‚¬
ì–•ì€ ë³µì‚¬ëŠ” í•„ë“œë¥¼ ë³µì‚¬í•˜ëŠ” ê²ƒì´ë‹¤. JVMì—ëŠ” ìŠ¤íƒê³¼ í™ ë©”ëª¨ë¦¬ë¡œ ë‚˜ë‰˜ì–´ ìŠ¤íƒì—ëŠ” í•„ë“œ, í™ì—ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ì €ì¥ë˜ì–´ í•„ë“œê°€ ì¸ìŠ¤í„´ìŠ¤ì˜ ì£¼ì†Œë¥¼ ê°€ì§€ëŠ” í˜•íƒœë¡œ ê°ì²´ê°€ ìƒì„±ëœë‹¤. ì´ ë•Œ, ì–•ì€ ë³µì‚¬ë¥¼ í•˜ê²Œë˜ë©´ ìŠ¤íƒì— ìˆëŠ” í•„ë“œë§Œ ë³µì œë˜ê³  í™ì— ìˆëŠ” ì¸ìŠ¤í„´ìŠ¤ëŠ” ë³µì œë˜ì§€ ì•ŠëŠ”ë‹¤. ì¦‰ ì›ë³¸ê³¼ ë³µì‚¬ë³¸ì´ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¸ì¡°í•œë‹¤. ë”°ë¼ì„œ ë³µì‚¬ë³¸ì„ ìˆ˜ì •í•˜ë©´ ì›ë³¸ë„ ìˆ˜ì •ëœë‹¤.

#### ê¹Šì€ ë³µì‚¬
ê¹Šì€ ë³µì‚¬ëŠ” í•„ë“œ, ì¸ìŠ¤í„´ìŠ¤ì™€ ì¸ìŠ¤í„´ìŠ¤ê°€ ì°¸ì¡°í•˜ëŠ” ëª¨ë“  ê°ì²´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë³µì‚¬í•œë‹¤. ì´ ê²½ìš°, ë³µì‚¬ë³¸ê³¼ ì›ë³¸ì€ ì™„ì „íˆ ë¶„ë¦¬ëœë‹¤.

```java
copyMap = new int[row][column];

for (int i=0; i<map.length; i++) {
    copyMap[i] = map[i].clone(); // ê¹Šì€ ë³µì‚¬
}

    copyMap = map.clone(); // << ì–•ì€ ë³µì‚¬
```

ìœ„ ì½”ë“œì˜ ê²½ìš° `Object.clone()`ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ë¥¼ ë³µì‚¬í–ˆëŠ”ë°, ì´ ë©”ì„œë“œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì–•ì€ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•œë‹¤. ê·¸ëŸ°ë° íŠ¹ìˆ˜í•˜ê²Œ  ì›ì‹œíƒ€ì…ì˜ ë°°ì—´ì¸ ê²½ìš°ì—ëŠ” ê¹Šì€ ë³µì‚¬ë¥¼ í•˜ë„ë¡ êµ¬í˜„ë˜ì–´ ìˆë‹¤.

#### ê²°ê³¼
ì–•ì€ ë³µì‚¬ë¡œ ì„ì‹œ ì—°êµ¬ì†Œë¥¼ ë§Œë“¤ì—ˆë‹¤ë©´ ì„ì‹œ ì—°êµ¬ì†Œì— ë°”ì´ëŸ¬ìŠ¤ë¥¼ í¼íŠ¸ë ¤ë„ ì‹¤ì œ ì—°êµ¬ì†Œê¹Œì§€ ë°”ì´ëŸ¬ìŠ¤ê°€ í¼ì§„ë‹¤.

ë”°ë¼ì„œ `copyMap[i] = map[i].clone(); `ì˜ ê²½ìš°ëŠ” ì›ì‹œíƒ€ì…ì˜ ë°°ì—´(ex. {1, 2, 3, 0, 5})ì„ ë³µì‚¬í•˜ëŠ” ê²ƒì´ë‹¤. í•˜ì§€ë§Œ `copyMap = map.clone();` ì„ í•˜ê²Œ ë˜ë©´ 2ì°¨ì› ë°°ì—´(ex. {{1, 2}, {3, 4}}ì„ ë³µì‚¬í•˜ë¯€ë¡œ ì›ì‹œíƒ€ì… ë°°ì—´ì˜ `clone`ì´ ì•„ë‹ˆë¼ì„œ ì–•ì€ ë³µì‚¬ë¥¼ ì§„í–‰í•˜ê²Œ ëœë‹¤.

## ì •ë¦¬
ì´ ë¬¸ì œê°€ 54%ì˜ ì •ë‹µë¥ ì„ ê°€ì§„ ê²ƒì— ë†€ëë‹¤. ì´ë³´ë‹¤ ë‚®ì€ ì •ë‹µë¥ ì¸ë°ë„ ë” ì‰¬ìš´ ë¬¸ì œë“¤ë„ ë§ì•˜ëŠ”ë° ì‚¬ëŒë“¤ì´ ì´ë ‡ê²Œë‚˜ ì˜í•˜ë‚˜.. ìƒê°ì´ ë“¤ì—ˆë‹¤. ì•„ë‹ˆë©´ ë‚˜ì²˜ëŸ¼ ì •ë‹µì„ ë´¤ì„ ìˆ˜ë„ ìˆê² ë‹¤.

DFS ë¬¸ì œ, BFS ë¬¸ì œ ê°ê°ì€ ë§ì´ í’€ì–´ë´¤ì§€ë§Œ ë‘ ê°œë¥¼ ë™ì‹œì— ì‚¬ìš©í•œ ì ì€ ì²˜ìŒì¸ ê²ƒ ê°™ë‹¤. ë•ë¶„ì— ê·¸ë˜í”„ ë¬¸ì œì—ì„œì˜ ì•ˆëª©ì´ ë„“ì–´ì§„ ê²ƒ ê°™ë‹¤. ë˜, ì§€ë‚˜ì¹˜ê²Œ ì œì•½ì¡°ê±´ì´ ê´€ëŒ€í•œ ê²½ìš° ì´ë ‡ê²Œ ì‹œê°„ë³µì¡ë„ê°€ ë³µì¡í•  ìˆ˜ ìˆë‹¤ëŠ” ëœ»ìœ¼ë¡œ ìƒê°í•´ë„ ì¢‹ì„ ë“¯í•˜ë‹¤.

ì–´ì©Œë‹¤ë³´ë‹ˆ `clone()`ì„ ì‚¬ìš©í•˜ëŠ” ì–•ì€ ë³µì‚¬ì™€ ê¹Šì€ ë³µì‚¬ì— ëŒ€í•´ ê³µë¶€í•´ë³¼ ìˆ˜ ìˆì—ˆë‹¤. ì½”ë”©í…ŒìŠ¤íŠ¸ ê³µë¶€ë„ í•˜ë©° ìë°” ê³µë¶€ë„ í•  ìˆ˜ ìˆìœ¼ë©´ ê·¸ë§Œí•œ ì¼ì„ì´ì¡°ê°€ ì—†ëŠ” ë“¯ í•˜ë‹¤.
